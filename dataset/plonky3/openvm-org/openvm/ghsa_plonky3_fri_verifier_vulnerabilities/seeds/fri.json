{
  "bug_id": "GHSA-4w7p-8f9q-f4g2",
  "description": "Two FRI verifier vulnerabilities: (1) missing beta^2 randomness in folding, (2) missing final polynomial degree check",
  "upstream_advisory": "Plonky3 GHSA-f69f-5fx9-w9r9",
  "commits": {
    "vulnerable": "7548bdf844db53c0a6fc9ed9f153c54422c6cfa4",
    "fixed": "bdb4831fefed13b0741d3a052d434a9c995c6d5d"
  },
  "scope": {
    "native_verifier": {
      "affected_by": ["missing_beta_squared", "missing_length_check"],
      "description": "Plonky3 SDK/CLI verification path",
      "fix_source": "Plonky3 dependency update"
    },
    "recursive_verifier": {
      "affected_by": ["missing_beta_squared"],
      "not_affected_by": ["missing_length_check"],
      "description": "OpenVM on-chain EVM verifier path",
      "fix_source": "OpenVM recursion code update",
      "note": "final_poly degree fixed to 0, no length check needed"
    }
  },
  "oracles": {
    "beta_squared_oracle": {
      "type": "behavioral",
      "function": "oracle_missing_beta_squared",
      "returns": "true if beta_squared not used (vulnerable)",
      "performance": "<1μs per invocation"
    },
    "length_check_oracle": {
      "type": "validation",
      "function": "oracle_missing_length_check",
      "returns": "true if length not checked (vulnerable)",
      "performance": "<1μs per invocation"
    }
  },
  "test_cases": {
    "beta_squared_randomness": [
      {
        "name": "folding_with_nonzero_reduced_opening",
        "eval_0": 100,
        "eval_1": 200,
        "beta": 5,
        "reduced_opening": 50,
        "expected_vulnerable": "folded = 100 + 5*200 = 1100 (missing beta^2 term)",
        "expected_fixed": "folded = 100 + 5*200 + 25*50 = 2350 (includes beta^2 term)",
        "note": "Results differ showing missing randomness"
      },
      {
        "name": "folding_with_zero_reduced_opening",
        "eval_0": 100,
        "eval_1": 200,
        "beta": 5,
        "reduced_opening": 0,
        "expected_vulnerable": "folded = 1100",
        "expected_fixed": "folded = 1100",
        "note": "Results same when reduced_opening=0 (beta^2 term vanishes)"
      },
      {
        "name": "various_beta_values",
        "betas": [2, 3, 5, 7, 10, 100],
        "property": "beta^2 must equal beta * beta",
        "test_type": "property_based"
      }
    ],
    "final_poly_length": [
      {
        "name": "length_zero_expected_zero",
        "actual_length": 0,
        "expected_length": 0,
        "expected_vulnerable": "NotChecked (accepts)",
        "expected_fixed": "Pass (correct length)"
      },
      {
        "name": "length_16_expected_zero",
        "actual_length": 16,
        "expected_length": 0,
        "expected_vulnerable": "NotChecked (accepts wrong length!)",
        "expected_fixed": "Fail (rejects wrong length)",
        "severity": "CRITICAL"
      },
      {
        "name": "various_lengths",
        "test_lengths": [0, 1, 2, 4, 8, 16, 32],
        "expected_length": 0,
        "note": "OpenVM recursion expects degree 0 (constant)"
      }
    ]
  },
  "why_not_fuzz": {
    "reason": "Verifier-level bug requires FRI proof generation (too slow)",
    "proving_cost": "1-10 seconds per proof",
    "throughput": "~0.05-0.5 exec/sec (vs 10,000+ needed for fuzzing)",
    "infrastructure_gaps": [
      "No FRI proof mutation API",
      "Complex proof format (commitments, openings, queries)",
      "Would need to regenerate full proof after mutation",
      "Verification itself is expensive"
    ],
    "recommended_instead": [
      "Property-based testing on folding logic (1M+ exec/sec)",
      "Static analysis of verifier code (instant)",
      "Unit testing of beta^2 computation (very fast)",
      "Symbolic execution (if FRI circuit IR available)"
    ]
  },
  "property_based_testing": {
    "framework": "QuickCheck or PropTest",
    "properties": [
      {
        "name": "beta_squared_equality",
        "description": "beta^2 == beta * beta for all beta",
        "performance": "1M+ exec/sec"
      },
      {
        "name": "folding_completeness",
        "description": "Fixed folding includes all 3 terms",
        "performance": "1M+ exec/sec"
      },
      {
        "name": "folding_differential",
        "description": "Vulnerable vs fixed differ when reduced_opening ≠ 0",
        "performance": "1M+ exec/sec"
      },
      {
        "name": "length_enforcement",
        "description": "Fixed rejects wrong lengths, vulnerable doesn't check",
        "performance": "Instant (enum comparison)"
      }
    ],
    "total_tests": "100+ random cases in <100ms"
  },
  "proof_mutation_complexity": {
    "fri_proof_structure": {
      "commit_phase_commits": "Array of Merkle commitments",
      "commit_phase_openings": "Polynomial evaluations at query points",
      "query_proofs": "Merkle proofs for opened values",
      "final_poly": "Final low-degree polynomial coefficients",
      "pow_witness": "Proof of work nonce"
    },
    "mutation_challenges": [
      "Must maintain Merkle tree consistency",
      "Openings must match commitments",
      "Query proofs must be valid",
      "Beta values are derived via Fiat-Shamir (can't arbitrarily set)",
      "final_poly coefficients must satisfy FRI equation"
    ],
    "why_difficult": "FRI proof has tight coupling between all components - can't mutate one field without invalidating others",
    "alternative": "Test the LOGIC (folding formula) not the PROOF STRUCTURE"
  },
  "test_recommendations": {
    "primary": "Property-based testing on folding logic (DONE in unit tests)",
    "secondary": "Static analysis of verifier source (DONE in harness tests)",
    "not_recommended": "Traditional fuzzing with full FRI proof generation",
    "performance_target": "1M+ exec/sec for logic testing"
  },
  "validation_strategy": {
    "step1": "Unit tests validate folding logic and length checks (DONE)",
    "step2": "Harness tests detect betas_squared in source (DONE)",
    "step3": "Property tests validate beta^2 correctness (DONE)",
    "step4": "Static analysis confirms fix patterns (DONE)",
    "step5": "Optional: Symbolic execution on FRI circuit (requires specialized tools)"
  },
  "fuzzing_verdict": {
    "traditional_fuzzing": "NOT RECOMMENDED (0.05 exec/sec too slow)",
    "property_based_testing": "HIGHLY RECOMMENDED (1M+ exec/sec)",
    "static_analysis": "HIGHLY RECOMMENDED (instant)",
    "exhaustive_testing": "NOT FEASIBLE (FRI proof space too large)",
    "overall": "Use property-based testing and static analysis, NOT traditional fuzzing"
  },
  "performance_comparison": {
    "logic_testing": {
      "throughput": "1,000,000+ exec/sec",
      "what_it_tests": "Folding formula, beta^2 computation",
      "limitation": "Doesn't test actual FRI circuit"
    },
    "proof_mutation": {
      "throughput": "100-1000 exec/sec (if infrastructure existed)",
      "what_it_tests": "Verifier accept/reject behavior",
      "limitation": "Infrastructure doesn't exist, complex to build"
    },
    "full_proving": {
      "throughput": "0.05-0.5 exec/sec",
      "what_it_tests": "End-to-end FRI protocol",
      "limitation": "Way too slow for fuzzing"
    },
    "recommendation": "Use logic testing (1M+ exec/sec)"
  },
  "notes": {
    "upstream_bug": "Bug originates in Plonky3, affects OpenVM",
    "fix_approach": "OpenVM updated recursion code to match Plonky3 fix",
    "verifier_distinction": "Native and recursive verifiers have different scope",
    "testing_level": "Logic-level testing sufficient to demonstrate vulnerability",
    "fuzzing_value": "LOW for full proofs, HIGH for logic testing"
  }
}

