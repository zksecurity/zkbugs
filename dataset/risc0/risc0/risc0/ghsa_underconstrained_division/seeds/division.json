{
  "bug_id": "GHSA-f6rc-24x4-ppxp",
  "description": "Division circuit under-constrained: (1) signed division allows multiple outputs, (2) division by zero underconstrained",
  "commits": {
    "vulnerable": "c8fd3bd2e2e18ad7a5abce213a376432116db039",
    "fixed": "bef7bf580eb13d5467074b5f6075a986734d3fe5",
    "backport": "b9eba23f5140edc968012e3f8e6b26bd62544a26"
  },
  "oracle": {
    "type": "behavioral_determinism",
    "function": "oracle_division_determinism",
    "returns": "true if non-deterministic (vulnerable), false if deterministic (fixed)",
    "performance": "<1Î¼s per invocation (pure arithmetic)"
  },
  "critical_test_cases": [
    {
      "name": "min_int_div_neg_one",
      "numer": -2147483648,
      "denom": -1,
      "expected_vulnerable": "multiple_results",
      "vulnerable_options": [
        {"quot": -2147483648, "rem": 0, "note": "Correct: overflow wraps"},
        {"quot": 2147483647, "rem": -1, "note": "Incorrect but allowed"}
      ],
      "expected_fixed": {"quot": -2147483648, "rem": 0},
      "description": "MIN_INT / -1 overflow case - mathematically undefined, two's complement wraps",
      "severity": "CRITICAL"
    },
    {
      "name": "div_by_zero_positive",
      "numer": 42,
      "denom": 0,
      "expected_vulnerable": "multiple_results",
      "vulnerable_options": [
        {"quot": 0, "rem": 42},
        {"quot": -1, "rem": 42},
        {"quot": 42, "rem": 0},
        {"quot": 2147483647, "rem": -2147483648}
      ],
      "expected_fixed": {"quot": -1, "rem": 42},
      "description": "Division by zero (positive numerator) - per RISC-V spec should return -1",
      "severity": "CRITICAL"
    },
    {
      "name": "div_by_zero_negative",
      "numer": -42,
      "denom": 0,
      "expected_vulnerable": "multiple_results",
      "expected_fixed": {"quot": -1, "rem": -42},
      "description": "Division by zero (negative numerator) - RISC-V spec: DIV returns -1",
      "severity": "CRITICAL"
    },
    {
      "name": "div_by_zero_zero",
      "numer": 0,
      "denom": 0,
      "expected_vulnerable": "multiple_results",
      "expected_fixed": {"quot": -1, "rem": 0},
      "description": "Zero divided by zero - RISC-V spec: still returns -1",
      "severity": "HIGH"
    }
  ],
  "edge_case_boundaries": {
    "signed_i32": {
      "MIN": -2147483648,
      "MIN_PLUS_1": -2147483647,
      "NEGATIVE_ONE": -1,
      "ZERO": 0,
      "ONE": 1,
      "TWO": 2,
      "MAX_MINUS_1": 2147483646,
      "MAX": 2147483647
    },
    "unsigned_u32": {
      "ZERO": 0,
      "ONE": 1,
      "TWO": 2,
      "MAX_MINUS_1": 4294967294,
      "MAX": 4294967295
    }
  },
  "test_case_sets": {
    "powers_of_two": {
      "description": "Division with powers of 2 to test bit-shift edge cases",
      "values": [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824],
      "include_negative": true,
      "test_count": 62
    },
    "div_by_zero_all_numerators": {
      "description": "Division by zero with all critical numerator values",
      "numerators": [-2147483648, -2147483647, -1000, -1, 0, 1, 1000, 2147483646, 2147483647],
      "denom": 0,
      "expected_quot": -1,
      "expected_rem": "same_as_numer"
    },
    "min_int_denominators": {
      "description": "MIN_INT with various denominators",
      "numer": -2147483648,
      "denoms": [-2, -1, 1, 2, -2147483648, 2147483647],
      "critical_case": {"denom": -1, "quot": -2147483648, "rem": 0}
    }
  },
  "division_invariant": {
    "formula": "numer == quot * denom + rem",
    "constraints": [
      "|rem| < |denom| (for non-zero denom)",
      "rem has same sign as numer or is zero",
      "Unique solution: for given (numer, denom), exists exactly one (quot, rem)"
    ],
    "special_cases": {
      "div_by_zero": "Invariant doesn't apply (can't multiply by zero to verify)",
      "overflow": "Use wrapping arithmetic to verify invariant"
    }
  },
  "riscv_spec_division": {
    "DIV_signed": {
      "normal": "quot = numer / denom, rem = numer % denom",
      "div_by_zero": "quot = -1, rem = numer",
      "overflow_MIN_by_neg1": "quot = MIN_INT (wraps), rem = 0"
    },
    "DIVU_unsigned": {
      "normal": "quot = numer / denom, rem = numer % denom",
      "div_by_zero": "quot = MAX (all 1s), rem = numer"
    },
    "REM_signed": "Returns remainder of DIV",
    "REMU_unsigned": "Returns remainder of DIVU"
  },
  "why_not_fuzz": {
    "reason": "Circuit-level bug requires full proving (too slow)",
    "proving_cost": "1-10 seconds per test case",
    "throughput": "~0.1-1 exec/sec (vs 50,000+ needed for fuzzing)",
    "infrastructure_gaps": [
      "No receipt mutation API",
      "Cannot inject malicious witness values",
      "Need custom circuit evaluation harness",
      "Would need to generate TWO proofs per input to detect non-determinism"
    ],
    "recommended_instead": [
      "Property-based testing (QuickCheck, PropTest)",
      "Exhaustive edge case testing",
      "Symbolic execution (Picus tool)",
      "SMT-based constraint analysis"
    ]
  },
  "property_based_testing": {
    "framework": "QuickCheck or PropTest",
    "properties": [
      {
        "name": "determinism",
        "description": "For any (numer, denom), division always returns same result",
        "test": "multiple calls with same input must return identical output"
      },
      {
        "name": "invariant",
        "description": "numer == quot * denom + rem",
        "test": "verify equation holds for all valid divisions"
      },
      {
        "name": "uniqueness",
        "description": "Exactly one valid (quot, rem) for each (numer, denom)",
        "test": "no alternative solution satisfies invariant + remainder constraints"
      },
      {
        "name": "remainder_bound",
        "description": "|rem| < |denom| for non-zero denom",
        "test": "remainder magnitude always less than divisor magnitude"
      }
    ],
    "performance": "1,000,000+ exec/sec (pure arithmetic)",
    "coverage": "Can exhaustively test all ~1000 interesting edge cases in <1 second"
  },
  "exhaustive_testing_feasibility": {
    "total_i32_space": "18,446,744,073,709,551,616 combinations (2^32 * 2^32)",
    "interesting_cases": "~1,000 edge cases",
    "edge_case_categories": [
      "Boundaries: MIN, MIN+1, -1, 0, 1, MAX-1, MAX",
      "Powers of 2: 1, 2, 4, ..., 2^30 (positive and negative)",
      "Division by zero: all critical numerators with denom=0",
      "MIN_INT cases: MIN_INT with various denominators"
    ],
    "test_duration": "<1 second for all edge cases",
    "recommendation": "Exhaustive testing is FEASIBLE and PREFERRED over fuzzing"
  },
  "symbolic_execution_approach": {
    "tool": "Picus (from Veridise)",
    "how_found": "This vulnerability was discovered using Picus",
    "approach": "Analyze circuit constraints symbolically to detect underconstrained variables",
    "advantages": [
      "Can prove absence of constraints",
      "Finds all underconstrained cases",
      "No false negatives",
      "Works at circuit level without proving"
    ],
    "limitation": "Requires access to circuit IR, not publicly available for RISC0"
  },
  "test_recommendations": {
    "primary": "Property-based testing with exhaustive edge cases (DONE in unit tests)",
    "secondary": "Symbolic execution if circuit IR available",
    "not_recommended": "Traditional fuzzing (too slow, wrong abstraction level)"
  },
  "fuzzing_oracle_for_arithmetic": {
    "oracle_name": "oracle_division_determinism",
    "input": "(numer: i32, denom: i32)",
    "output": "bool (true if vulnerable)",
    "implementation": "Compare vulnerable emulator (multiple results) vs fixed emulator (single result)",
    "usage": "Property-based testing, NOT traditional fuzzing",
    "performance_note": "Fast enough for property testing (1M+ exec/sec), but doesn't test actual circuit"
  },
  "validation_strategy": {
    "step1": "Unit tests validate division logic (DONE)",
    "step2": "Property tests validate invariants (DONE)",
    "step3": "Exhaustive edge case testing (DONE)",
    "step4": "Regression tests for known problematic inputs (DONE)",
    "step5": "Optional: Symbolic execution on actual circuit (requires Picus/similar tool)"
  },
  "notes": {
    "testing_level": "Arithmetic logic only (no circuit testing)",
    "why_sufficient": "Demonstrates the vulnerability pattern and fix at logic level",
    "actual_bug_location": "Circuit constraints in risc0-circuit-rv32im",
    "test_target": "Division algorithm properties, not circuit constraints",
    "generalization": "These property tests apply to ANY division implementation (zkVM or otherwise)"
  }
}

